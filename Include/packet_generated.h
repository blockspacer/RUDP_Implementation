// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_PACKET_H_
#define FLATBUFFERS_GENERATED_PACKET_H_

#include "flatbuffers/flatbuffers.h"

struct Packet;

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROT_ID = 4,
    VT_SEQUENCE = 6,
    VT_ACK = 8,
    VT_ACK_BITFIELD = 10,
    VT_MESSAGE_ID = 12,
    VT_FRAGMENT_COUNT = 14,
    VT_BUFFER = 16
  };
  uint32_t prot_id() const { return GetField<uint32_t>(VT_PROT_ID, 0); }
  uint32_t sequence() const { return GetField<uint32_t>(VT_SEQUENCE, 0); }
  uint32_t ack() const { return GetField<uint32_t>(VT_ACK, 0); }
  uint32_t ack_bitfield() const { return GetField<uint32_t>(VT_ACK_BITFIELD, 0); }
  uint32_t message_id() const { return GetField<uint32_t>(VT_MESSAGE_ID, 0); }
  uint32_t fragment_count() const { return GetField<uint32_t>(VT_FRAGMENT_COUNT, 0); }
  const flatbuffers::Vector<uint8_t> *buffer() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROT_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE) &&
           VerifyField<uint32_t>(verifier, VT_ACK) &&
           VerifyField<uint32_t>(verifier, VT_ACK_BITFIELD) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_ID) &&
           VerifyField<uint32_t>(verifier, VT_FRAGMENT_COUNT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BUFFER) &&
           verifier.Verify(buffer()) &&
           verifier.EndTable();
  }
};

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prot_id(uint32_t prot_id) { fbb_.AddElement<uint32_t>(Packet::VT_PROT_ID, prot_id, 0); }
  void add_sequence(uint32_t sequence) { fbb_.AddElement<uint32_t>(Packet::VT_SEQUENCE, sequence, 0); }
  void add_ack(uint32_t ack) { fbb_.AddElement<uint32_t>(Packet::VT_ACK, ack, 0); }
  void add_ack_bitfield(uint32_t ack_bitfield) { fbb_.AddElement<uint32_t>(Packet::VT_ACK_BITFIELD, ack_bitfield, 0); }
  void add_message_id(uint32_t message_id) { fbb_.AddElement<uint32_t>(Packet::VT_MESSAGE_ID, message_id, 0); }
  void add_fragment_count(uint32_t fragment_count) { fbb_.AddElement<uint32_t>(Packet::VT_FRAGMENT_COUNT, fragment_count, 0); }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) { fbb_.AddOffset(Packet::VT_BUFFER, buffer); }
  PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    auto o = flatbuffers::Offset<Packet>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t prot_id = 0,
   uint32_t sequence = 0,
   uint32_t ack = 0,
   uint32_t ack_bitfield = 0,
   uint32_t message_id = 0,
   uint32_t fragment_count = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_fragment_count(fragment_count);
  builder_.add_message_id(message_id);
  builder_.add_ack_bitfield(ack_bitfield);
  builder_.add_ack(ack);
  builder_.add_sequence(sequence);
  builder_.add_prot_id(prot_id);
  return builder_.Finish();
}

inline const Packet *GetPacket(const void *buf) { return flatbuffers::GetRoot<Packet>(buf); }

inline bool VerifyPacketBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<Packet>(); }

inline void FinishPacketBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<Packet> root) { fbb.Finish(root); }


#endif  // FLATBUFFERS_GENERATED_PACKET_H_
